
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Example 13 - Using Unstructured Grids &#8212; dorado 2.2.0 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="License" href="../misc/license.html" />
    <link rel="prev" title="Example 12 - Unsteady Flow Fields" href="example12.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="example-13-using-unstructured-grids">
<span id="example13"></span><h1>Example 13 - Using Unstructured Grids<a class="headerlink" href="#example-13-using-unstructured-grids" title="Permalink to this headline">¶</a></h1>
<p>This workbook provides an example workflow for running particles on an
unstructured model output (i.e. flow variables are from a non-Cartesian
grid). We make use of several of the geospatial functions in
<code class="docutils literal notranslate"><span class="pre">particle_track.py</span></code> and others in <code class="docutils literal notranslate"><span class="pre">routines.py</span></code>, in order to show
how to grid hydrodynamic input files, convert UTM coordinates into (and
out of) the array coordinates used in routing the particles, as well as
how to compute exposure times to a region of interest. Hopefully this
example in conjunction with other examples can provide information on
how users can adapt these codes to their use-case.</p>
<p>Full example workbook available <a class="reference download internal" download="" href="../_downloads/540650a058baed2c28facdae43c7dbf2/unstructured_grid_anuga.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">here</span></code></a>.</p>
<p>To demonstrate this functionality, we make use of outputs from the
hydrodynamic model <a class="reference external" href="https://github.com/GeoscienceAustralia/anuga_core">ANUGA</a>,
which solves the 2D shallow-water equations on a triangular mesh. We’ve
extracted outputs from a previous example model run and included these
as text files in the repository, so as to avoid importing any
dependencies not required by this distribution. If the user is also
using ANUGA flow-fields, there is a a commented-out block of code below
demonstrating how we extracted the input files for use in this workbook.</p>
<div class="section" id="import-necessary-dependencies">
<h2>Import necessary dependencies<a class="headerlink" href="#import-necessary-dependencies" title="Permalink to this headline">¶</a></h2>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">dorado</span>
<span class="kn">import</span> <span class="nn">dorado.particle_track</span> <span class="k">as</span> <span class="nn">pt</span>
</pre></div>
</div>
</div>
<div class="section" id="load-in-model-outputs">
<h2>Load in model outputs<a class="headerlink" href="#load-in-model-outputs" title="Permalink to this headline">¶</a></h2>
<p>If we were starting directly from an ANUGA output file, this is where we
would import the outputs from the model run. We have included these
files directly with the distribution, but for anyone interested in
repeating the steps we used to generate these files, uncomment the block
of code below.</p>
<p>Here, <code class="docutils literal notranslate"><span class="pre">path2file</span></code> should point to the ANUGA output file
(e.g. <code class="docutils literal notranslate"><span class="pre">./model_output.sww</span></code>). This output is a NetCDF file with flow
variables (e.g. <code class="docutils literal notranslate"><span class="pre">depth</span></code>, <code class="docutils literal notranslate"><span class="pre">xmom</span></code>, <code class="docutils literal notranslate"><span class="pre">stage</span></code>) listed by triangle
index, along with the centroid coordinates (<code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>) of that
triangle. In our case, those coordinates are in meters UTM, which will
be relevant later.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># # Import anuga to access functions (NOTE: Anuga requires Python 2.7!)</span>
<span class="c1"># import anuga</span>

<span class="c1"># # Folder name of run to analyze:</span>
<span class="c1"># path2file = &#39;examples/example_model.sww&#39;</span>

<span class="c1"># # Extract the files from NetCDF using Anuga&#39;s `get_centroids` function:</span>
<span class="c1"># swwvals = anuga.utilities.plot_utils.get_centroids(path2file, timeSlices = &#39;last&#39;)</span>
<span class="c1"># # Query values: time, x, y, stage, elev, height, xmom, ymom, xvel, yvel, friction, vel, etc</span>

<span class="c1"># # Here, since we are only interested in saving variables, we migrate variables to a dictionary:</span>
<span class="c1"># # Make sure to filter out NaN&#39;s before converting to lists, if there are any</span>
<span class="c1"># unstructured = dict()</span>
<span class="c1"># unstructured[&#39;x&#39;] = swwvals.x.tolist()</span>
<span class="c1"># unstructured[&#39;y&#39;] = swwvals.y.tolist()</span>
<span class="c1"># unstructured[&#39;depth&#39;] = swwvals.height[0].tolist()</span>
<span class="c1"># unstructured[&#39;stage&#39;] = swwvals.stage[0].tolist()</span>
<span class="c1"># unstructured[&#39;qx&#39;] = swwvals.xmom[0].tolist()</span>
<span class="c1"># unstructured[&#39;qy&#39;] = swwvals.ymom[0].tolist()</span>

<span class="c1"># # And then we save this dictionary into a json (text) file for later import</span>
<span class="c1"># json.dump(unstructured, open(&#39;unstructured_model.txt&#39;, &#39;w&#39;))</span>
<span class="c1"># # This generates the file imported in this workbook</span>
</pre></div>
</div>
<p>Here, we will skip the above step and just import the
<code class="docutils literal notranslate"><span class="pre">unstructured_model.txt</span></code> dictionary.</p>
<p><strong>Note</strong>: We have chosen to save/import the variables <code class="docutils literal notranslate"><span class="pre">depth</span></code>,
<code class="docutils literal notranslate"><span class="pre">stage</span></code>, <code class="docutils literal notranslate"><span class="pre">qx</span></code>, and <code class="docutils literal notranslate"><span class="pre">qy</span></code> in this application. However, we could
have chosen to save and use the fields <code class="docutils literal notranslate"><span class="pre">topography</span></code>, <code class="docutils literal notranslate"><span class="pre">u</span></code>, and <code class="docutils literal notranslate"><span class="pre">v</span></code>
(or in ANUGA’s terminology, <code class="docutils literal notranslate"><span class="pre">elev</span></code>, <code class="docutils literal notranslate"><span class="pre">xvel</span></code>, and <code class="docutils literal notranslate"><span class="pre">yvel</span></code>). The
particle tracking code accepts any of these inputs, as long as you
provide enough information to calculate the water surface slope, depth
of the water column, and the two components of inertia.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="n">unstructured</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;unstructured_model.txt&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="convert-data-and-coordinates-for-particle-routing">
<h2>Convert data and coordinates for particle routing<a class="headerlink" href="#convert-data-and-coordinates-for-particle-routing" title="Permalink to this headline">¶</a></h2>
<p>Now that we have the data we need, we can convert it into the format
needed by <code class="docutils literal notranslate"><span class="pre">dorado</span></code>. This will include gridding the
hydrodynamic outputs and transforming our geospatial coordinates into
“array index” coordinates.</p>
<p>First, let’s combine our <img class="math" src="../_images/math/497184a5e83d0159a4bf15b0bb89dc5aa40cce7d.png" alt="(x,y)"/> coordinates into a list of
tuples. This is the expected format for coordinates in the following
functions.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use list comprehension to convert into tuples</span>
<span class="n">coordinates</span> <span class="o">=</span> <span class="p">[(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])))]</span>

<span class="c1"># Let&#39;s see the extent of our domain</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span>
      <span class="nb">min</span><span class="p">(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]))</span>
<span class="c1"># As well as our number of data points</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mf">624422.25</span><span class="p">,</span> <span class="mf">625031.9375</span><span class="p">,</span> <span class="mf">3346870.0</span><span class="p">,</span> <span class="mf">3347107.75</span><span class="p">)</span>
<span class="mi">103558</span>
</pre></div>
</div>
<p>Now, let’s grid our unstructured data into a uniform grid. For this, we
make use of the function <code class="docutils literal notranslate"><span class="pre">particle_track.unstruct2grid()</span></code>, which uses
inverse-distance-weighted interpolation to create a Cartesian grid the
same size as our model’s extent. To use this function, we need to
provide: - Our list of <code class="docutils literal notranslate"><span class="pre">coordinates</span></code> (as tuples). - The unstructured
data we want to be gridded (here we start with <code class="docutils literal notranslate"><span class="pre">depth</span></code>). - The desired
grid size of the resulting rasters (here we’re using <img class="math" src="../_images/math/96fc100bed84677eaee925344911851cce8cdb01.png" alt="1 m"/>,
because the test model was on high-resolution lidar data). - The
number of <img class="math" src="../_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/> nearest neighbors to use in the interpolation. If
<img class="math" src="../_images/math/e0c697f0cf4a4c09fb151f725bdc6e65c3be447c.png" alt="k=1"/>, we use only the nearest datapoint, whereas higher values
(default is <img class="math" src="../_images/math/a60f3b4a3531f65bb5a1b11f886d291ff8ccaef5.png" alt="k=3"/>) interpolate the data into a smoother result.</p>
<p>The underlying code relies on <code class="docutils literal notranslate"><span class="pre">scipy</span></code> to build a <code class="docutils literal notranslate"><span class="pre">cKDTree</span></code> of our
unstructured data, which maps the datapoints onto a uniform array.
<code class="docutils literal notranslate"><span class="pre">cKDTree</span></code> is much faster than other gridding functions
(e.g. <code class="docutils literal notranslate"><span class="pre">scipy.interpolate.griddata</span></code>), but building the tree can still
be very slow if the dataset is very large or if the desired grid size is
very small.</p>
<p>The outputs of <code class="docutils literal notranslate"><span class="pre">unstruct2grid</span></code> are: - The resulting interpolation
function <code class="docutils literal notranslate"><span class="pre">myInterp</span></code> (after building the nearest-distance tree), which
will be considerably faster than calling <code class="docutils literal notranslate"><span class="pre">unstruct2grid</span></code> again if we
are gridding additional datasets. This function assumes data have the
same coordinates, grid size, and <img class="math" src="../_images/math/0b7c1e16a3a8a849bb8ffdcdbf86f65fd1f30438.png" alt="k"/>. - A gridded array of our
data.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use IDW interpolation interpolate unstructured data into uniform grid</span>
<span class="n">myInterp</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">unstruct2grid</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1"># Let&#39;s plot the resulting grid to see what the output looks like:</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">fraction</span><span class="o">=</span><span class="mf">0.018</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Gridded Depth Array&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../_images/unstructured_grid_anuga_10_1.png" src="../_images/unstructured_grid_anuga_10_1.png" />
<p>Now, let’s use the new function <code class="docutils literal notranslate"><span class="pre">myInterp</span></code> to grid our additional
datasets. If <code class="docutils literal notranslate"><span class="pre">unstruct2grid</span></code> took a while to grid the first dataset,
this function will be considerably faster than re-running that process,
because it re-uses most of the results of that first function call. This
function only requires as input the new unstructured data to be gridded.</p>
<p>All of these variables will have the same grid size as the first
dataset, and we assume that they have all the same coordinates.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># Grid other data products with new interpolation function</span>
<span class="n">stage</span> <span class="o">=</span> <span class="n">myInterp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;stage&#39;</span><span class="p">]))</span>
<span class="n">qx</span> <span class="o">=</span> <span class="n">myInterp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;qx&#39;</span><span class="p">]))</span>
<span class="n">qy</span> <span class="o">=</span> <span class="n">myInterp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;qy&#39;</span><span class="p">]))</span>
<span class="c1"># Should be very fast compared to the first dataset!</span>

<span class="c1"># Let&#39;s plot one of these variables to see the new grid</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">qy</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;seismic&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">fraction</span><span class="o">=</span><span class="mf">0.018</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Gridded Y-Discharge Array&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../_images/unstructured_grid_anuga_12_1.png" src="../_images/unstructured_grid_anuga_12_1.png" />
<p><strong>Note:</strong> In all these cases, if your unstructured data does not fill
the full rectangular domain, IDW interpolation may still populate those
exterior regions with data. If this has potential to cause problems when
routing particles, make sure to do some pre-processing on these rasters
to correct those exterior regions or crop the domain.</p>
<p>Now, let’s figure out where we want to seed our particles. If you’re
modeling a real domain, it may be easier to figure out a good release
location by opening some GIS software and finding the coordinates of
that location. Here, we will use the function
<code class="docutils literal notranslate"><span class="pre">particle_track.coord2ind()</span></code> to convert your coordinates into array
indices. This function requires: - Coordinates to be converted, as a
list [] of <img class="math" src="../_images/math/497184a5e83d0159a4bf15b0bb89dc5aa40cce7d.png" alt="(x,y)"/> tuples - The location of the lower left corner
of your rasters (i.e. the origin). If you used <code class="docutils literal notranslate"><span class="pre">unstruct2grid</span></code> to
generate rasters, this location will be <code class="docutils literal notranslate"><span class="pre">[(min(x),</span> <span class="pre">min(y))]</span></code>.
Otherwise, if you’re loading data from e.g. a GeoTIFF, the lower left
corner will be stored in the .tif metadata and can be accessed by GIS
software or gdalinfo (if the user has GDAL) - The dimensions of the
raster, accessible via <code class="docutils literal notranslate"><span class="pre">np.shape(raster)</span></code> - The grid size of the
raster (here <img class="math" src="../_images/math/3250cb5323c088f155c19d90b245821b2207b186.png" alt="1m"/>).</p>
<p><strong>Note:</strong> this coordinate transform flips the orientation of the unit
vectors (i.e. <img class="math" src="../_images/math/da85f3cdb6e4f6d76e24acd89b0830548fa2b3cb.png" alt="y_{index} = x"/> and <img class="math" src="../_images/math/58f66904f1de73ad72ba528a6646c9bc09459aed.png" alt="x_{index} = -y"/>) and
returns raster indices. This is convenient for the internal
functions of <code class="docutils literal notranslate"><span class="pre">particle_tools.py</span></code>, but may cause confusion with
plotting or interpreting later if locations are not translated back into
spatial coordinates. (Don’t worry, we will convert back later!)</p>
<p>We assume in all of these functions that the coordinates you’re using
are (at least locally) flat. We do not account for the curvature of the
Earth in very large domains. Hopefully you are using a projected
coordinate system (here we are using meters UTM), or at least willing to
accept a little distortion. Note that this <code class="docutils literal notranslate"><span class="pre">coord2ind</span></code> requires units
of either meters or decimal degrees.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># I have found a nice release location in GIS. Let&#39;s convert it to index notation:</span>
<span class="n">seedloc</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">624464</span><span class="p">,</span> <span class="mi">3347078</span><span class="p">)]</span> <span class="c1"># Coordinates are in meters UTM</span>

<span class="c1"># Call the coordinate transform function</span>
<span class="n">seedind</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">coord2ind</span><span class="p">(</span><span class="n">seedloc</span><span class="p">,</span>
                       <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span>
                        <span class="nb">min</span><span class="p">(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">])),</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">depth</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">seedind</span><span class="p">)</span>

<span class="c1"># Visualize the location on our array</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">seedind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">seedind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">fraction</span><span class="o">=</span><span class="mf">0.03</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Gridded Depth Array&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="n">seedind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="n">seedind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">100</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="n">seedind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">70</span><span class="p">,</span> <span class="n">seedind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">30</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">42</span><span class="p">)]</span>
</pre></div>
</div>
<img alt="../_images/unstructured_grid_anuga_15_2.png" src="../_images/unstructured_grid_anuga_15_2.png" />
</div>
<div class="section" id="set-up-particle-routing-parameters">
<h2>Set up particle routing parameters<a class="headerlink" href="#set-up-particle-routing-parameters" title="Permalink to this headline">¶</a></h2>
<p>Now that we have pre-converted the input data we need, let’s set up the
particle routing to be run. We do this using the
<code class="docutils literal notranslate"><span class="pre">particle_track.modelParams</span></code> class, in which we populate the attributes to
suit our application. This includes the gridded hydrodynamic outputs from
above, the grid size <code class="docutils literal notranslate"><span class="pre">dx</span></code>, and tuning parameters which influence our random walk.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the parameters object and then assign the values</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">modelParams</span><span class="p">()</span>

<span class="c1"># Populate the params attributes</span>
<span class="n">params</span><span class="o">.</span><span class="n">stage</span> <span class="o">=</span> <span class="n">stage</span>
<span class="n">params</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
<span class="n">params</span><span class="o">.</span><span class="n">qx</span> <span class="o">=</span> <span class="n">qx</span>
<span class="n">params</span><span class="o">.</span><span class="n">qy</span> <span class="o">=</span> <span class="n">qy</span>

<span class="c1"># Other choices/parameters</span>
<span class="n">params</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># Grid size</span>
<span class="n">params</span><span class="o">.</span><span class="n">dry_depth</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="c1"># 1 cm considered dry</span>
<span class="c1"># You can also tell it which model you&#39;re using, but this only matters if the answer is DeltaRCM:</span>
<span class="n">params</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="s1">&#39;Anuga&#39;</span>
</pre></div>
</div>
<p>In this application, we are using the default values for the parameters
of the random walk (<code class="docutils literal notranslate"><span class="pre">gamma</span></code>, <code class="docutils literal notranslate"><span class="pre">theta</span></code>, <code class="docutils literal notranslate"><span class="pre">diff_coeff</span></code>). I encourage
you to play with these weights and see how your solution is affected.</p>
</div>
<div class="section" id="generate-particles">
<h2>Generate particles<a class="headerlink" href="#generate-particles" title="Permalink to this headline">¶</a></h2>
<p>Now we instantiate the <code class="docutils literal notranslate"><span class="pre">particle_track.Particles</span></code> class, and generate
some particles to be routed. Here we are using the <code class="docutils literal notranslate"><span class="pre">'random'</span></code> method
to generate particles, which seeds them randomly within a specified region.
If we knew exactly where we wanted particles, we could call the
<code class="docutils literal notranslate"><span class="pre">'exact'</span></code> method instead.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># Now we seed in the region +/- 1 cell of the seed location we computed earlier</span>
<span class="c1"># Note that &quot;xloc&quot; and &quot;yloc&quot; are x and y in the particle coordinate system!</span>
<span class="n">params</span><span class="o">.</span><span class="n">seed_xloc</span> <span class="o">=</span> <span class="p">[</span><span class="n">seedind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">seedind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="n">params</span><span class="o">.</span><span class="n">seed_yloc</span> <span class="o">=</span> <span class="p">[</span><span class="n">seedind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">seedind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># For this example, we model 50 particles:</span>
<span class="n">params</span><span class="o">.</span><span class="n">Np_tracer</span> <span class="o">=</span> <span class="mi">50</span>

<span class="c1"># Initialize particles and generate particles</span>
<span class="n">particles</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">Particles</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="n">particles</span><span class="o">.</span><span class="n">generate_particles</span><span class="p">(</span><span class="n">Np_tracer</span><span class="p">,</span> <span class="n">seed_xloc</span><span class="p">,</span> <span class="n">seed_yloc</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Theta</span> <span class="n">parameter</span> <span class="ow">not</span> <span class="n">specified</span> <span class="o">-</span> <span class="n">using</span> <span class="mf">1.0</span>
<span class="n">Gamma</span> <span class="n">parameter</span> <span class="ow">not</span> <span class="n">specified</span> <span class="o">-</span> <span class="n">using</span> <span class="mf">0.05</span>
<span class="n">Diffusion</span> <span class="n">coefficient</span> <span class="ow">not</span> <span class="n">specified</span> <span class="o">-</span> <span class="n">using</span> <span class="mf">0.2</span>
<span class="n">Cell</span> <span class="n">Types</span> <span class="ow">not</span> <span class="n">specified</span> <span class="o">-</span> <span class="n">Estimating</span> <span class="kn">from</span> <span class="nn">depth</span>
<span class="n">Using</span> <span class="n">weighted</span> <span class="n">random</span> <span class="n">walk</span>
</pre></div>
</div>
</div>
<div class="section" id="run-the-particle-routing">
<h2>Run the particle routing<a class="headerlink" href="#run-the-particle-routing" title="Permalink to this headline">¶</a></h2>
<p>Now we call on one of the routines, <code class="docutils literal notranslate"><span class="pre">routines.steady_plots()</span></code>, to run
the model. The core of the particle routing occurs in the
<code class="docutils literal notranslate"><span class="pre">particle_track.run_iteration()</span></code> function, but for ease of use, we
have provided several high-level wrappers for the underlying code in the
<code class="docutils literal notranslate"><span class="pre">routines.py</span></code> script. These routines take common settings, run the
particle routing, and save a variety of plots and data for
visualization.</p>
<p>Because our model is a steady case (i.e. flow-field is not varying with
time), <code class="docutils literal notranslate"><span class="pre">steady_plots</span></code> will run the particles for an equal number of
iterations and return the travel history to us in the <code class="docutils literal notranslate"><span class="pre">walk_data</span></code>
dict. This dict is organized into <code class="docutils literal notranslate"><span class="pre">['xinds']</span></code>, <code class="docutils literal notranslate"><span class="pre">['yinds']</span></code>, and
<code class="docutils literal notranslate"><span class="pre">['travel_times']</span></code>, which are then indexed by particle ID, and then
finally iteration number. (e.g. <code class="docutils literal notranslate"><span class="pre">walk_data['xinds'][5][10]</span></code> will
return the xindex for the 6th particle’s 11th iteration).</p>
<p>Note that, while this function returns a <code class="docutils literal notranslate"><span class="pre">walk_data</span></code> dictionary, this
information is also stored as an attribute of the particles class,
accessible via <code class="docutils literal notranslate"><span class="pre">particles.walk_data</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># Using steady (time-invariant) plotting routine for 200 iterations</span>
<span class="n">walk_data</span> <span class="o">=</span> <span class="n">dorado</span><span class="o">.</span><span class="n">routines</span><span class="o">.</span><span class="n">steady_plots</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="s1">&#39;unstructured_grid_anuga&#39;</span><span class="p">)</span>
<span class="c1"># Outputs will be saved in the folder &#39;unstructured_grid_anuga&#39;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">100</span><span class="o">%|</span><span class="c1">################################################################################| 200/200 [02:44&lt;00:00,  1.21it/s]</span>
</pre></div>
</div>
<p>Because the particles take different travel paths, at any given
iteration they are <em>not guaranteed</em> to be synced up in time. We can
check this using the <code class="docutils literal notranslate"><span class="pre">routines.get_state()</span></code> function, which allows us
to slice the <code class="docutils literal notranslate"><span class="pre">walk_data</span></code> dictionary along a given iteration number.
This function logically indexes the dict like
<code class="docutils literal notranslate"><span class="pre">walk_data[:][:][iteration]</span></code>, except not quite as simple given the
indexing rules of a nested list.</p>
<p>By default, this function will return the most recent step (iteration
number <code class="docutils literal notranslate"><span class="pre">-1</span></code>), but we could ask it to slice along any given iteration
number.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">ti</span> <span class="o">=</span> <span class="n">dorado</span><span class="o">.</span><span class="n">routines</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span><span class="n">walk_data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">([</span><span class="nb">round</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ti</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mf">284.1</span><span class="p">,</span> <span class="mf">292.6</span><span class="p">,</span> <span class="mf">301.7</span><span class="p">,</span> <span class="mf">293.1</span><span class="p">,</span> <span class="mf">294.2</span><span class="p">,</span> <span class="mf">319.2</span><span class="p">,</span> <span class="mf">275.1</span><span class="p">,</span> <span class="mf">332.2</span><span class="p">,</span> <span class="mf">302.7</span><span class="p">,</span> <span class="mf">273.2</span><span class="p">,</span>
<span class="mf">303.0</span><span class="p">,</span> <span class="mf">303.4</span><span class="p">,</span> <span class="mf">297.2</span><span class="p">,</span> <span class="mf">304.5</span><span class="p">,</span> <span class="mf">281.1</span><span class="p">,</span> <span class="mf">297.7</span><span class="p">,</span> <span class="mf">270.8</span><span class="p">,</span> <span class="mf">300.1</span><span class="p">,</span> <span class="mf">299.0</span><span class="p">,</span> <span class="mf">318.7</span><span class="p">,</span>
<span class="mf">274.5</span><span class="p">,</span> <span class="mf">293.8</span><span class="p">,</span> <span class="mf">288.5</span><span class="p">,</span> <span class="mf">397.7</span><span class="p">,</span> <span class="mf">332.9</span><span class="p">,</span> <span class="mf">274.3</span><span class="p">,</span> <span class="mf">271.1</span><span class="p">,</span> <span class="mf">302.7</span><span class="p">,</span> <span class="mf">298.6</span><span class="p">,</span> <span class="mf">314.4</span><span class="p">,</span>
<span class="mf">317.9</span><span class="p">,</span> <span class="mf">284.3</span><span class="p">,</span> <span class="mf">332.5</span><span class="p">,</span> <span class="mf">294.8</span><span class="p">,</span> <span class="mf">313.7</span><span class="p">,</span> <span class="mf">302.1</span><span class="p">,</span> <span class="mf">291.5</span><span class="p">,</span> <span class="mf">311.6</span><span class="p">,</span> <span class="mf">326.2</span><span class="p">,</span> <span class="mf">302.1</span><span class="p">,</span>
<span class="mf">274.0</span><span class="p">,</span> <span class="mf">307.0</span><span class="p">,</span> <span class="mf">275.0</span><span class="p">,</span> <span class="mf">273.7</span><span class="p">,</span> <span class="mf">317.2</span><span class="p">,</span> <span class="mf">367.2</span><span class="p">,</span> <span class="mf">272.9</span><span class="p">,</span> <span class="mf">307.9</span><span class="p">,</span> <span class="mf">294.5</span><span class="p">,</span> <span class="mf">280.6</span><span class="p">]</span>
</pre></div>
</div>
<p><strong>Note:</strong> There exists an equivalent function, <code class="docutils literal notranslate"><span class="pre">get_time_state()</span></code>,
which slices <code class="docutils literal notranslate"><span class="pre">walk_data</span></code> along a given
travel time, in case there is interest in viewing the particles in sync.</p>
<p>As a brief aside, the particle routing can also be run in an <em>unsteady</em>
way, in which each particle continues taking steps until each has
reached a specified <code class="docutils literal notranslate"><span class="pre">target_time</span></code>. This can be useful if you want to
visualize particle travel times in “real time”, or if you want to sync
up their propagation with an unsteady flow field that updates every so
often (e.g. every 30 minutes). This can be done either with the
<code class="docutils literal notranslate"><span class="pre">unsteady_plots()</span></code> routine, or by interacting with <code class="docutils literal notranslate"><span class="pre">run_iteration()</span></code>
directly. The commented-out block of code below shows an example of what
an unsteady case might look like, had we used more timesteps from the
model output.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># # Specify folder to save figures:</span>
<span class="c1"># path2folder = &#39;unstructured_grid_anuga&#39;</span>

<span class="c1"># # Let&#39;s say our model outputs update minute:</span>
<span class="c1"># model_timestep = 60. # Units in seconds</span>
<span class="c1"># # Number of steps to take in total:</span>
<span class="c1"># num_steps = 20</span>
<span class="c1"># # Create vector of target times</span>
<span class="c1"># target_times = np.arange(model_timestep,</span>
<span class="c1">#                          model_timestep*(num_steps+1),</span>
<span class="c1">#                          model_timestep)</span>

<span class="c1"># # Iterate through model timesteps</span>
<span class="c1"># for i in list(range(num_steps)):</span>
<span class="c1">#     # The main functional difference with an unsteady model is re-instantiating the</span>
<span class="c1">#     # particle class with updated params *inside* the particle routing loop</span>

<span class="c1">#     # Update the flow field by gridding new time-step</span>
<span class="c1">#     # We don&#39;t have additional timesteps, but if we did, we update params here:</span>
<span class="c1">#     params.depth = myInterp(unstructured[&#39;depth&#39;])</span>
<span class="c1">#     params.stage = myInterp(unstructured[&#39;stage&#39;])</span>
<span class="c1">#     params.qx = myInterp(unstructured[&#39;qx&#39;])</span>
<span class="c1">#     params.qy = myInterp(unstructured[&#39;qy&#39;])</span>

<span class="c1">#     # Define the particle class and continue</span>
<span class="c1">#     particle = pt.Particles(params)</span>
<span class="c1">#     # Generate some particles</span>
<span class="c1">#     if i == 0:</span>
<span class="c1">#         particle.generate_particles(Np_tracer, seed_xloc, seed_yloc)</span>
<span class="c1">#     else:</span>
<span class="c1">#         particle.generate_particles(0, [], [], &#39;random&#39;, walk_data)</span>

<span class="c1">#     # Run the random walk for this &quot;model timestep&quot;</span>
<span class="c1">#     walk_data = particle.run_iteration(target_times[i])</span>

<span class="c1">#     # Use get_state() to return original and most recent locations</span>
<span class="c1">#     x0, y0, t0 = dorado.routines.get_state(walk_data, 0) # Starting locations</span>
<span class="c1">#     xi, yi, ti = dorado.routines.get_state(walk_data) # Most recent locations</span>

<span class="c1">#     # Make and save plots and data</span>
<span class="c1">#     fig = plt.figure(dpi=200)</span>
<span class="c1">#     ax = fig.add_subplot(111)</span>
<span class="c1">#     ax.scatter(y0, x0, c=&#39;b&#39;, s=0.75)</span>
<span class="c1">#     ax.scatter(yi, xi, c=&#39;r&#39;, s=0.75)</span>
<span class="c1">#     ax = plt.gca()</span>
<span class="c1">#     im = ax.imshow(particle.depth)</span>
<span class="c1">#     plt.title(&#39;Depth at Time &#39; + str(target_times[i]))</span>
<span class="c1">#     cax = fig.add_axes([ax.get_position().x1+0.01,</span>
<span class="c1">#                         ax.get_position().y0,</span>
<span class="c1">#                         0.02,</span>
<span class="c1">#                         ax.get_position().height])</span>
<span class="c1">#     cbar = plt.colorbar(im, cax=cax)</span>
<span class="c1">#     cbar.set_label(&#39;Water Depth [m]&#39;)</span>
<span class="c1">#     plt.savefig(path2folder + &#39;/output_by_dt&#39;+str(i)+&#39;.png&#39;)</span>
<span class="c1">#     plt.close()</span>
</pre></div>
</div>
</div>
<div class="section" id="analyze-the-outputs">
<h2>Analyze the outputs<a class="headerlink" href="#analyze-the-outputs" title="Permalink to this headline">¶</a></h2>
<p>Now that we have the walk history stored in <code class="docutils literal notranslate"><span class="pre">walk_data</span></code>, we can query
this dictionary for features of interest. For starters, we can convert
the location indices back into geospatial coordinates using the function
<code class="docutils literal notranslate"><span class="pre">particle_track.ind2coord()</span></code>. This will append the existing dictionary
with <code class="docutils literal notranslate"><span class="pre">['xcoord']</span></code> and <code class="docutils literal notranslate"><span class="pre">['ycoord']</span></code> fields in the units we started
with (meters or decimal degrees).</p>
<p><strong>Note:</strong> Particle locations are only known to within the specified grid
size (i.e. +/- dx/2)</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert particle location indices back into UTM coordinates</span>
<span class="n">walk_data</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">ind2coord</span><span class="p">(</span><span class="n">walk_data</span><span class="p">,</span>
                         <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span>
                          <span class="nb">min</span><span class="p">(</span><span class="n">unstructured</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">])),</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">depth</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># To check that things have worked, print starting location of first particle.</span>
<span class="c1"># Should be within +/- dx from seedloc = (624464, 3347078)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">walk_data</span><span class="p">[</span><span class="s1">&#39;xcoord&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">walk_data</span><span class="p">[</span><span class="s1">&#39;ycoord&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mf">624465.25</span><span class="p">,</span> <span class="mf">3347079.0</span><span class="p">)</span>
</pre></div>
</div>
<p>For something a little more interesting, let’s measure the amount of
time particles spent “exposed” to a specific sub-region within our
domain. For this we make use of the functions
<code class="docutils literal notranslate"><span class="pre">particle_track.exposure_time()</span></code> and
<code class="docutils literal notranslate"><span class="pre">routines.plot_exposure_time()</span></code>. If we input a binary array (same size
as input arrays) delineating our region of interest (ROI) with 1’s,
these functions will compute and plot the exposure time distribution
(ETD) of particles in this sub-region.</p>
<p>For those familiar with the metric, the ETD is equivalent to the
residence time distribution (RTD) for steady flows, with the only
difference being that if particles make multiple excursions into our
ROI, all those times are counted.</p>
<p><strong>Note:</strong> For a representative ETD, it is important to run a <em>lot</em> of
particles. A large sample size is needed to obtain a realistic
distribution (and smooth plots). Depending on the domain, we recommend at
least <img class="math" src="../_images/math/e728045d42b977ff8bad7b2582b5ede1dd0b76bd.png" alt="O(10^3)"/>.</p>
<p>First, let’s generate and visualize the ROI:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the array</span>
<span class="n">regions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
<span class="n">regions</span><span class="p">[:,</span><span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Include anywhere above sea level</span>

<span class="c1"># Visualize the region</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">regions</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;bone&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../_images/unstructured_grid_anuga_29_1.png" src="../_images/unstructured_grid_anuga_29_1.png" />
<p>Then compute. <code class="docutils literal notranslate"><span class="pre">exposure_time()</span></code> outputs a list of exposure times by
particle index, and <code class="docutils literal notranslate"><span class="pre">plot_exposure_time()</span></code> will use those values to
generate plots of the cumulative and differential forms of the ETD
(i.e. the CDF and PDF, respectively).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="c1"># Measure exposure times</span>
<span class="n">exposure_times</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">exposure_time</span><span class="p">(</span><span class="n">walk_data</span><span class="p">,</span>
                                  <span class="n">regions</span><span class="p">)</span>
<span class="c1"># Then generate plots and save data</span>
<span class="n">exposure_times</span> <span class="o">=</span> <span class="n">dorado</span><span class="o">.</span><span class="n">routines</span><span class="o">.</span><span class="n">plot_exposure_time</span><span class="p">(</span><span class="n">walk_data</span><span class="p">,</span>
                                                    <span class="n">exposure_times</span><span class="p">,</span>
                                                    <span class="s1">&#39;unstructured_grid_anuga/figs&#39;</span><span class="p">,</span>
                                                    <span class="n">timedelta</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="c1"># Changing &#39;timedelta&#39; will change the units of the time-axis.</span>
<span class="c1"># Units are seconds, so 60 will plot by minute.</span>
<span class="c1"># Because we are using fewer particles than ideal, smooth the plots with small &#39;nbins&#39;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">100</span><span class="o">%|</span><span class="c1">#################################################################################| 50/50 [00:00&lt;00:00, 1190.48it/s]</span>
</pre></div>
</div>
<img alt="../_images/unstructured_grid_anuga_31_2.png" src="../_images/unstructured_grid_anuga_31_2.png" />
<img alt="../_images/unstructured_grid_anuga_31_3.png" src="../_images/unstructured_grid_anuga_31_3.png" />
<p><strong>Note:</strong> If any particles are still in the ROI at the end of their
travel history, they are excluded from plots. These particles are not
done being “exposed,” so we need to run more iterations in order to
capture the tail of the distribution.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">dorado</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install/index.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart/index.html">Quickstart</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../background/index.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../paper/index.html">Paper</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userguide/index.html">User Guide</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Examples</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="example01.html">Example 1 - Particles in Steady Flow (ANUGA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="example02.html">Example 2 - Particles in Steady Flow (DeltaRCM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="example03.html">Example 3 - Using the Built-In Animation Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="example04.html">Example 4 - Toggling Steepest Descent</a></li>
<li class="toctree-l2"><a class="reference internal" href="example05.html">Example 5 - Visualizing Particle Travel Times</a></li>
<li class="toctree-l2"><a class="reference internal" href="example06.html">Example 6 - Set Travel Time Target</a></li>
<li class="toctree-l2"><a class="reference internal" href="example07.html">Example 7 - Drawing Particle Travel Paths (DeltaRCM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="example08.html">Example 8 - Drawing Particle Travel Paths (ANUGA)</a></li>
<li class="toctree-l2"><a class="reference internal" href="example09.html">Example 9 - True Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="example10.html">Example 10 - Routing Particles in Parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="example11.html">Example 11 - The Travel Time Diffusion Coefficient</a></li>
<li class="toctree-l2"><a class="reference internal" href="example12.html">Example 12 - Unsteady Flow Fields</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Example 13 - Using Unstructured Grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#external-examples">External Examples</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../misc/license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc/contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../apiref/index.html">API Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../misc/acknowledgments.html">Acknowledgments</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Examples</a><ul>
      <li>Previous: <a href="example12.html" title="previous chapter">Example 12 - Unsteady Flow Fields</a></li>
      <li>Next: <a href="../misc/license.html" title="next chapter">License</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, J. Hariharan, K. Wright, P. Passalacqua.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/examples/example13.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>